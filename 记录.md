# Linux 内核机制学习记录
## x86内核保护机制下的编程
### 26 - 01 - 04
&emsp; &emsp; 只是按照视频搭建加载过程

### 26 - 01 - 05
&emsp; &emsp; 理解了一点进入保护模式前的一些设置  

- 需要设置一个全局描述符（结构体数组）进行**属性配置**，根据内核数据段和代码段在全局描述符中对应的索引位置，对数据段和代码段的描述符进行属性配置（每个段对应一个64位值用于配置），具体代码如下:

<center> source/os.c : </center>

```c 
...
struct {uint16_t limit_l, base_l, basehl_attr, base_limit;}gdt_table[256] __attribute__((aligned(8))) = {
    [KERNEL_CODE_SEG / 8] = {0xFFFF, 0x0000, 0x9A00, 0x00CF},
    [KERNEL_DATA_SEG / 8] = {0xFFFF, 0x0000, 0x9200, 0x00CF},
};
...
```

<center> source/os.h : </center>

```c
...
#define KERNEL_CODE_SEG 0x08
#define KERNEL_DATA_SEG 0x10
...
```

- 涉及到的汇编代码主要是切换为**保护模式**——加载全局描述符->设置CR0寄存器PE位->远跳转->重新加载段寄存器，具体如下：
  
```asm
...
read_self_all:
	mov $start_32, %bx
	mov $0x02, %cx
	mov $0x240, %ax
	mov $0x80, %dx
	int $0x13 
	jc read_self_all
	// 下面的代码将处理器从实模式切换到保护模式
	cli                     // 关中断
	lgdt gdt_desc      // 加载全局描述符表
	mov $1, %eax          // 设置CR0寄存器的PE位
	lmsw %ax
	jmp $KERNEL_CODE_SEG, $start_32  // 跳转到32位代码段

	.org 0x1fe
	.byte 0x55, 0xaa  // 引导扇区的结束标志    

	// 32位保护模式, 位于512字节后
	.code32
	.text
    start_32:
	// 下面的代码将段寄存器重新加载为保护模式下的段选择子
	mov $KERNEL_DATA_SEG, %ax
	mov %ax, %ds
	mov %ax, %es
	mov %ax, %ss
	mov %ax, %gs
	mov %ax, %fs
	mov $_start, %esp
	jmp .

gdt_desc:
	.word (256 * 8) - 1	  // GDT表界限
	.long gdt_table                 // GDT表基地址
...
```


### 26 - 01 - 06
&emsp; &emsp; 学习分页机制——虚拟内存映射物理内存的一种机制

- 创建第一级页表——采用**PDE-4MB映射**
&emsp; &emsp; 这个页表元素采用**直接映射**——4MB以内的虚拟地址直接对应物理地址
```c
uint32_t pg_dir[1024] __attribute__((aligned(4096)))= {
    [0] = (0x00000000 | PDE_P | PDE_W | PDE_U | PDE_PS),          // 前4MB，4MB大页
};
```

- 创建第二级页表
```c
static uint32_t pg_table[1024] __attribute__((aligned(4096))) = {11};
```

- 创建实际物理地址buffer
```c
uint8_t map_phy_buffer[4096] __attribute__((aligned(4096))) = {123};
```

- 实现二级页表映射

&emsp; &emsp; 若map_phy_buffer实际地址位于4MB内，则其地址直接对应实际内存的物理地址
```c
void os_init(void){
    pg_dir[MAP_PHY_ADDR >> 22] = ((uint32_t)pg_table | PDE_P | PDE_W | PDE_U); 
    pg_table[MAP_PHY_ADDR >> 12 & 0x3FF] = (uint32_t)map_phy_buffer | PDE_P | PDE_W | PDE_U;
}
```

- 汇编代码的分页机制启动操作
```asm
	call os_init  // 调用os_init函数初始化操作系统
	
	// 下面的代码启用分页机制
	mov $pg_dir, %eax
	mov %eax, %cr3         // 加载页目录基地址到CR3寄存器

	mov %cr4, %eax
	orl $(1 << 4), %eax  // 设置CR4寄存器的PSE位
	mov %eax, %cr4        // 启用分页机制

	mov %cr0, %eax
	orl $(1 << 31), %eax  // 设置CR0寄存器的PG位
	mov %eax, %cr0        // 启用分页机制
```

### 26 - 01 - 07
&emsp; &emsp; 配置定时器

- 在C代码中使用汇编函数**outb**

&emsp; &emsp; 将数据val存入AL寄存器先，把port作为**立即数**存入Dx寄存器先，最后执行outb命令，将 AL 中的值输出到 port 指定的 I/O 端口
```c
void outb(uint8_t val, uint16_t port){
    __asm__ __volatile__ (
        "outb %0, %1"
        :
        : "a"(val), "d"(port)
    );
}
```

- 使用outb配置定时器

&emsp; &emsp; 这段代码通过向8259A中断控制器的特定端口写入配置值，配置了计算机的中断系统：首先向命令端口（0x20/0xA0）写入0x11告知开始初始化和初始化后使用数据端口（0x21/0xA1）会依次写入什么寄存器（可以看到后续使用同一个端口但是实际上写入了不同的寄存器），然后通过数据端口依次设置中断号重映射（0-15→32-47）、级联连接、操作模式和中断频率。
```c
void os_init(void){
	...
    outb(0x11, 0x20); // 主片
    outb(0x11, 0xA0); // 从片
    outb(0x20, 0x21); // 主片中断0-7映射到32-39
    outb(0x28, 0xA1); // 从片中断8-15映射到40-47
    outb(0x04, 0x21); // 主片IR2接从片
    outb(0x02, 0xA1); // 从片级联标志
    outb(0x01, 0x21); // 8086模式
    outb(0x01, 0xA1); // 8086模式
    outb(0xff, 0x21); // 屏蔽所有中断
    outb(0xff, 0xA1); // 屏蔽所有中断
	
	// 设置时钟中断频率为100ms
    int clock_100ms = 1193180 / 100; 
    outb((uint8_t)clock_100ms, 0x40);
    outb((clock_100ms >> 8) & 0xFF, 0x40);
}
```

- IDT表初始化

&emsp; &emsp; IDT（中断描述符表）是一张由操作系统维护的跳转表，用于告诉CPU当中断发生时应该跳转到哪个函数去处理。要使用它，需要：1）创建一个描述符数组；2）为每个中断号填充对应的描述符，包括处理函数的地址、代码段选择子和权限属性；3）用lidt指令将表的地址和大小加载到CPU。这样当中断发生时，CPU就能自动查找并跳转到你指定的处理函数。
```c
struct{uint16_t offset_l, selector, attr, offset_h;}idt_table[256] __attribute__((aligned(8))) = {1};

void os_init(void){
	...

	idt_table[0x20].offset_l = irq0_handler & 0xFFFF;
    idt_table[0x20].selector = KERNEL_CODE_SEG;
    idt_table[0x20].attr = 0x8E00; 
    idt_table[0x20].offset_h = irq0_handler >> 16;
	...

	outb(0xFE, 0x21); // 取消中断屏蔽，打开时钟中断IRQ0
}
```

- 汇编需要的操作
- 1.描述并加载IDT表
- 2.开中断
- 3.描述中断处理内容，并且声明C代码里的中断函数
```c
	#include "os.h"
	// 声明本地以下符号是全局的，在其它源文件中可以访问
	.global _start, irq0_handler
	// 指定以下的代码生成16位的机器指令，这样才能在启动时的实模式下运行
  	.code16
	// 以下是代码区
 	.text
_start: 
    ...
	

read_self_all:
	...

	// 下面的代码将处理器从实模式切换到保护模式
	cli                     // 关中断
	lgdt gdt_desc      // 加载全局描述符表
	lidt idt_desc      // 加载中断描述符表
	...

	// 32位保护模式, 位于512字节后
	.code32
	.text
start_32:
	...

	sti					 // 开中断


irq0_handler:
	push %ds
	pusha
	mov $0x20, %al
	outb %al, $0x20       // 通知PIC芯片IRQ0中断处理完毕
	popa
	pop %ds
	iret

idt_desc:
	.word (256 * 8) - 1	  // IDT表界限
	.long idt_table                 // IDT表基地址
```