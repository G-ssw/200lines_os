# Linux 内核机制学习记录

## x86内核保护机制下的编程

### 26 - 01 - 04

> 只是按照视频搭建加载过程
---
### 26 - 01 - 05

> 理解了一点进入保护模式前的一些设置
#### 📝细节之处1:

需要设置一个全局描述符（**结构体数组**）进行**属性配置**，根据内核数据段和代码段在全局描述符中对应的索引位置，对数据段和代码段的描述符进行属性配置（每个段对应一个64位值用于配置），具体代码如下:

**source/os.c :**

```c
struct {uint16_t limit_l, base_l, basehl_attr, base_limit;}gdt_table[256] __attribute__((aligned(8))) = {
    [KERNEL_CODE_SEG / 8] = {0xFFFF, 0x0000, 0x9A00, 0x00CF},
    [KERNEL_DATA_SEG / 8] = {0xFFFF, 0x0000, 0x9200, 0x00CF},
};
```

**source/os.h :**

```c
#define KERNEL_CODE_SEG 0x08
#define KERNEL_DATA_SEG 0x10
```

涉及到的汇编代码主要是切换为**保护模式**`<br>`

- 1️⃣ 加载全局描述符
- 2️⃣ 设置CR0寄存器PE位
- 3️⃣ 远跳转
- 4️⃣ 重新加载段寄存器

具体可展开以下代码：

<details open>
<summary style="background: #24292e; color: #f6f8fa; padding: 9px; border-radius: 5px 5px 0 0; margin-bottom: -10px; font-family: monospace;">
  📄 source/start.s
</summary>

```asm
read_self_all:
	mov $start_32, %bx
	mov $0x02, %cx
	mov $0x240, %ax
	mov $0x80, %dx
	int $0x13 
	jc read_self_all
	// 下面的代码将处理器从实模式切换到保护模式
	cli                     // 关中断
	lgdt gdt_desc      // 加载全局描述符表
	mov $1, %eax          // 设置CR0寄存器的PE位
	lmsw %ax
	jmp $KERNEL_CODE_SEG, $start_32  // 跳转到32位代码段

	.org 0x1fe
	.byte 0x55, 0xaa  // 引导扇区的结束标志  

	// 32位保护模式, 位于512字节后
	.code32
	.text
    start_32:
	// 下面的代码将段寄存器重新加载为保护模式下的段选择子
	mov $KERNEL_DATA_SEG, %ax
	mov %ax, %ds
	mov %ax, %es
	mov %ax, %ss
	mov %ax, %gs
	mov %ax, %fs
	mov $_start, %esp
	jmp .

gdt_desc:
	.word (256 * 8) - 1	  // GDT表界限
	.long gdt_table                 // GDT表基地址
```
</details>


---
### :statue_of_liberty: 26 - 01 - 06

#### :page_with_curl:学习分页机制
分页机制是虚拟内存映射物理内存的一种机制

##### :one: 创建第一级页表——采用**PDE-4MB映射**
  这个页表元素采用**直接映射**——4MB以内的虚拟地址直接对应物理地址
```c
uint32_t pg_dir[1024] __attribute__((aligned(4096)))= {
    [0] = (0x00000000 | PDE_P | PDE_W | PDE_U | PDE_PS),          // 前4MB，4MB大页
};
```

##### :two: 创建第二级页表

```c
static uint32_t pg_table[1024] __attribute__((aligned(4096))) = {11};
```

##### :three: 创建实际物理地址buffer

```c
uint8_t map_phy_buffer[4096] __attribute__((aligned(4096))) = {123};
```

##### :four: 实现二级页表映射

  若map_phy_buffer实际地址位于4MB内，则其地址直接对应实际内存的物理地址

```c
void os_init(void){
    pg_dir[MAP_PHY_ADDR >> 22] = ((uint32_t)pg_table | PDE_P | PDE_W | PDE_U); 
    pg_table[MAP_PHY_ADDR >> 12 & 0x3FF] = (uint32_t)map_phy_buffer | PDE_P | PDE_W | PDE_U;
}
```

##### :five: 汇编代码的分页机制启动操作

```asm
	call os_init  // 调用os_init函数初始化操作系统

	// 下面的代码启用分页机制
	mov $pg_dir, %eax
	mov %eax, %cr3         // 加载页目录基地址到CR3寄存器

	mov %cr4, %eax
	orl $(1 << 4), %eax  // 设置CR4寄存器的PSE位
	mov %eax, %cr4        // 启用分页机制

	mov %cr0, %eax
	orl $(1 << 31), %eax  // 设置CR0寄存器的PG位
	mov %eax, %cr0        // 启用分页机制
```
---

### :clock1230: 26 - 01 - 07

#### C文件配置定时器

##### :one: 在C代码中使用汇编函数**outb**
将数据val存入AL寄存器先，把port作为**立即数**存入Dx寄存器先，最后执行outb命令，将 AL 中的值输出到 port 指定的 I/O 端口
<div style="background: #24292e; color: #f6f8fa; padding: 10px; border-radius: 5px 5px 0 0; margin-bottom: -3px; font-family: monospace; font-size: 14px; border-bottom: none;">
  📄 source/os.c
</div>

```c
void outb(uint8_t val, uint16_t port){
    __asm__ __volatile__ (
        "outb %0, %1"
        :
        : "a"(val), "d"(port)
    );
}
```

##### :two: 使用outb配置定时器
以下这段代码通过向8259A中断控制器的特定端口写入配置值，配置了计算机的中断系统:
- 首先向命令端口（**0x20/0xA0**）写入0x11告知开始初始化和初始化后使用数据端口（**0x21/0xA1**）会依次写入什么寄存器（可以看到后续使用同一个端口但是实际上写入了不同的寄存器）
- 然后通过数据端口依次设置中断号重映射（**0-15→32-47**）、级联连接、操作模式和中断频率。

<details open>
<summary style="background: #24292e; color: #f6f8fa; padding: 10px; border-radius: 5px 5px 0 0; margin-bottom: -10px; font-family: monospace;">
  📄 source/os.c
</summary>

```c
void os_init(void){
	...
    outb(0x11, 0x20); // 主片
    outb(0x11, 0xA0); // 从片
    outb(0x20, 0x21); // 主片中断0-7映射到32-39
    outb(0x28, 0xA1); // 从片中断8-15映射到40-47
    outb(0x04, 0x21); // 主片IR2接从片
    outb(0x02, 0xA1); // 从片级联标志
    outb(0x01, 0x21); // 8086模式
    outb(0x01, 0xA1); // 8086模式
    outb(0xff, 0x21); // 屏蔽所有中断
    outb(0xff, 0xA1); // 屏蔽所有中断

	// 设置时钟中断频率为100ms
    int clock_100ms = 1193180 / 100; 
    outb((uint8_t)clock_100ms, 0x40);
    outb((clock_100ms >> 8) & 0xFF, 0x40);
}
```
</details>

##### :three: IDT表初始化

**IDT**（中断描述符表）是一张由操作系统维护的跳转表，用于告诉CPU当中断发生时应该跳转到哪个函数去处理，要使用它，需要：<br>
- :one: 创建一个描述符数组
- :two: 为每个中断号填充对应的描述符，包括处理函数的地址、代码段选择子和权限属性
- :three: 用lidt指令将表的地址和大小加载到CPU。这样当中断发生时，CPU就能自动查找并跳转到你指定的处理函数。

<div style="background: #24292e; color: #f6f8fa; padding: 10px; border-radius: 5px 5px 0 0; margin-bottom: -3px; font-family: monospace; font-size: 14px; border-bottom: none;">
  📄 source/os.c
</div>

```c
struct{uint16_t offset_l, selector, attr, offset_h;}idt_table[256] __attribute__((aligned(8))) = {1};

void os_init(void){
	...

	idt_table[0x20].offset_l = irq0_handler & 0xFFFF;
    idt_table[0x20].selector = KERNEL_CODE_SEG;
    idt_table[0x20].attr = 0x8E00; 
    idt_table[0x20].offset_h = irq0_handler >> 16;
	...

	outb(0xFE, 0x21); // 取消中断屏蔽，打开时钟中断IRQ0
}
```

#### :page_with_curl:汇编需要的操作
- :one: 描述并加载IDT表
- :two: 开中断
- :three: 描述中断处理内容，并且声明C代码里的中断函数


<details open>
<summary style="background: #24292e; color: #f6f8fa; padding: 10px; border-radius: 5px 5px 0 0; margin-bottom: -3px; font-family: monospace; font-size: 14px; border-bottom: none;">
  📄 source/start.s
</summary>

```asm
	#include "os.h"
	// 声明本地以下符号是全局的，在其它源文件中可以访问
	.global _start, irq0_handler
	// 指定以下的代码生成16位的机器指令，这样才能在启动时的实模式下运行
  	.code16
	// 以下是代码区
 	.text
_start: 
    ...

read_self_all:
	...

	// 下面的代码将处理器从实模式切换到保护模式
	cli                     // 关中断
	lgdt gdt_desc      // 加载全局描述符表
	lidt idt_desc      // 加载中断描述符表
	...

	// 32位保护模式, 位于512字节后
	.code32
	.text
start_32:
	...

	sti					 // 开中断

irq0_handler:
	push %ds
	pusha
	mov $0x20, %al
	outb %al, $0x20       // 通知PIC芯片IRQ0中断处理完毕
	popa
	pop %ds
	iret

idt_desc:
	.word (256 * 8) - 1	  // IDT表界限
	.long idt_table                 // IDT表基地址
```
</details>

---
### 26 - 01 - 08
>:package: Github仓库配置 + :arrow_up: 上传
---
### 26 - 01 - 09
#### :warning: 切换至低特权级 + :performing_arts: 任务切换

##### :warning: 切换低特权级

- :one: 选用用户空间选择子 并设置其GDT描述符

<div style="background: #24292e; color: #f6f8fa; padding: 10px; border-radius: 5px 5px 0 0; margin-bottom: -3px; font-family: monospace; font-size: 14px; border-bottom: none;">
  📄 source/os.h
</div>

```c
#define APP_CODE_SEG    (0x18 | 3)
#define APP_DATA_SEG    (0x20 | 3)
```

<div style="background: #24292e; color: #f6f8fa; padding: 10px; border-radius: 5px 5px 0 0; margin-bottom: -3px; font-family: monospace; font-size: 14px; border-bottom: none;">
  📄 source/os.c
</div>

```c
struct {uint16_t limit_l, base_l, basehl_attr, base_limit;}gdt_table[256] __attribute__((aligned(8))) = {
    ...

    [APP_CODE_SEG / 8]    = {0xFFFF, 0x0000, 0xFA00, 0x00CF},
    [APP_DATA_SEG / 8]    = {0xFFFF, 0x0000, 0xF300, 0x00CF},
};
```

- :two: 刻意构造一次“中断-返回”机制，跳转低特权级任务

<div style="background: #24292e; color: #f6f8fa; padding: 10px; border-radius: 5px 5px 0 0; margin-bottom: -3px; font-family: monospace; font-size: 14px; border-bottom: none;">
  📄 source/start.s
</div>

```asm
start_32:
	...

	push $APP_DATA_SEG
	push $task_0_stack + 1024 * 4 // 任务0的栈顶地址
	// 以下代码模拟中断返回，跳转到任务0入口点运行
	push $0x202 	 // EFLAGS寄存器的IF位设置为1，启用中断
	push $APP_CODE_SEG
	push $task_0_entry
	iret              // 通过iret指令跳转到任务0入口点
	...

task_0_entry:
	mov %ss, %ax
	mov %ax, %ds
	mov %ax, %es
	mov %ax, %gs
	mov %ax, %fs
	jmp .

```


##### :performing_arts: 任务切换

- :one: 在.h头文件添加TSS选择子
<div style="background: #24292e; color: #f6f8fa; padding: 10px; border-radius: 5px 5px 0 0; margin-bottom: -3px; font-family: monospace; font-size: 14px; border-bottom: none;">
  📄 source/os.h
</div>

```c
#define TASK0_TSS_SEL   0x28
#define TASK1_TSS_SEL   0x30
```
- :two: 在C源文件补充必要数据结构
  - 任务栈<br>
  - 任务工作函数<br>
  - TSS详细定义<br>
  - 修改GDT表-添加TSS描述符<br>
  - 增加任务调度函数<br>


<div style="background: #24292e; color: #f6f8fa; padding: 10px; border-radius: 5px 5px 0 0; margin-bottom: -3px; font-family: monospace; font-size: 14px; border-bottom: none;">
  📄 source/os.c
</div>

```c
// 2.1 任务栈定义（每个任务需要两个栈：DPL0和DPL3）
uint32_t task0_dpl0_stack[1024], task0_dpl3_stack[1024];
uint32_t task1_dpl0_stack[1024], task1_dpl3_stack[1024];
...

// 2.2 任务工作函数
void task_0 (void) {
    for (;;) {
    }
}

void task_1(void) {
    for (;;) {
    }
}
...

// 2.3 TSS 详细定义
// 任务0的TSS定义
uint32_t task0_tss[] = {
    // prelink, esp0, ss0, esp1, ss1, esp2, ss2
    0,  (uint32_t)task0_dpl0_stack + 4*1024, KERNEL_DATA_SEG, 
    0x0, 0x0, 0x0, 0x0,  // esp1-ss2不用
  
    // cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi
    (uint32_t)pg_dir,  (uint32_t)task_0, 0x202,  // 页目录、入口点、标志
    0xa, 0xc, 0xd, 0xb,                         // eax, ecx, edx, ebx
    (uint32_t)task0_dpl3_stack + 4*1024,        // 用户栈（esp）
    0x1, 0x2, 0x3,                              // ebp, esi, edi
  
    // es, cs, ss, ds, fs, gs, ldt, iomap
    APP_DATA_SEG, APP_CODE_SEG, APP_DATA_SEG, 
    APP_DATA_SEG, APP_DATA_SEG, APP_DATA_SEG, 
    0x0, 0x0,                                   // ldt, iomap
};

// 任务1的TSS定义
uint32_t task1_tss[] = {
    // prelink, esp0, ss0, esp1, ss1, esp2, ss2
    0,  (uint32_t)task1_dpl0_stack + 4*1024, KERNEL_DATA_SEG,
    0x0, 0x0, 0x0, 0x0,
  
    // cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi
    (uint32_t)pg_dir,  (uint32_t)task_1, 0x202,
    0xa, 0xc, 0xd, 0xb,
    (uint32_t)task1_dpl3_stack + 4*1024,        // 用户栈
    0x1, 0x2, 0x3,
  
    // es, cs, ss, ds, fs, gs, ldt, iomap
    APP_DATA_SEG, APP_CODE_SEG, APP_DATA_SEG,
    APP_DATA_SEG, APP_DATA_SEG, APP_DATA_SEG,
    0x0, 0x0,
};
...

// 2.4 GDT表新增TSS项
struct {uint16_t limit_l, base_l, basehl_attr, base_limit;}gdt_table[256] __attribute__((aligned(8))) = {
    ...

    [TASK0_TSS_SEL / 8]   = {0x0068, 0, 0xE900, 0x0},  
    [TASK1_TSS_SEL / 8]   = {0x0068, 0, 0xE900, 0x0},
};
...

// 2.5 任务调度函数
void task_sched(void) {
    static int current_task = TASK0_TSS_SEL;
  
    // 切换任务
    if (current_task == TASK0_TSS_SEL) {
        current_task = TASK1_TSS_SEL;
    } else {
        current_task = TASK0_TSS_SEL;
    }
  
    // 使用远跳转切换到新任务
    // 这个数组[0, 选择子]构成一个48位远指针
    uint32_t jump_addr[] = {0, current_task};
  
    // ljmpl指令：跳转到TSS选择子，触发任务切换
    __asm__ __volatile__("ljmpl *(%0)" : : "r"(jump_addr));
}


// 2.6 os_init末尾添加TSS初始化
void os_init(void){
	...

    gdt_table[TASK0_TSS_SEL / 8].base_l = (uint16_t)((uint32_t)task0_tss & 0xFFFF);
    gdt_table[TASK0_TSS_SEL / 8].basehl_attr |= ((uint32_t)os_init >> 16) & 0xFF;
    gdt_table[TASK0_TSS_SEL / 8].base_limit |= ((uint32_t)task0_tss >> 24) << 24;
  
    gdt_table[TASK1_TSS_SEL / 8].base_l = (uint16_t)((uint32_t)task1_tss & 0xFFFF);
    gdt_table[TASK1_TSS_SEL / 8].basehl_attr |= ((uint32_t)task1_tss >> 16) & 0xFF;
    gdt_table[TASK1_TSS_SEL / 8].base_limit |= ((uint32_t)task1_tss >> 24) << 24;
}
```

- :three: 汇编文件修改
  - 修改start.S中的irq0_handler：
  - 修改start.S的start_32部分
  - 修改task0_entry

<div style="background: #24292e; color: #f6f8fa; padding: 10px; border-radius: 5px 5px 0 0; margin-bottom: -3px; font-family: monospace; font-size: 14px; border-bottom: none;">
  📄 source/start.s
</div>

```asm
...
// 3.1 修改irq0_handler
irq0_handler:
	...

    mov $KERNEL_DATA_SEG, %ax
    mov %ax, %ds
    mov %ax, %es
  
    call task_sched
	...

// 3.2 修改start_32
start_32:
    ...

    mov $TASK0_TSS_SEL, %ax
    ltr %ax

	push $APP_DATA_SEG
	push $task0_dpl0_stack + 1024 * 4 // 任务0的栈顶地址
    ...

// 3.3 修改task0_entry
task_0_entry:
    ...

	jmp task_0
```
---
### 26 - 01 - 10
#### :closed_book:小总结：
- :one: 对 26 - 01 - 09 的工作进行收尾
- :two: 增加系统调用 并在os_init中补充其起始地址的设置
- :three: limit_l 指定系统调用处理函数syscall_handler 在C文件和汇编文件提前声明
- :four: 在汇编函数增加 syscall_handler标签
- :five: 增加一个通用的函数 do_syscall, 这个函数是在syscall_handler函数里面使用的
- :six: 增加一个函数 sys_show, 这个函数主要功能就是显示字符串 涉及到一些在C语言内调用汇编的操作


>**烂尾两天** :arrow_right: 11号早上完成了系统调用功能 但没记录，12号考试后摆烂一天，13号仅1个多小时
---

### 26 - 01 - 13 —— 26 - 01 - 23
#### 这几天做了什么：
- 考试一周
- 结合Deepseek重新总结x86保护模式知识

### 26 - 01 - 24

> 今天创建了新的工程 **diy-x86Linux**，并且为远程仓库新建分支提交，也为新的工程模板编译通过排查了一些错误，如vscode的启动需要**管理员权限**，**image路径**根据自己需要需要修改，有时不能成功写入磁盘时，把image文件夹下的文件全部清除，再把新的磁盘文件复制进去即可
>
#### 引导程序：
- 添加boot工程:arrow_right:寄存器初始化 + 读取磁盘扇区
- 添加loader子工程：
  - :one: boot工程首先在汇编执行了x86保护模式内容 
  - :two: 后通过C文件跳转到 boot_entry 函数当中
  - :three: 定义宏，指向loader工程的执行程序在内存中的首地址
  - :four: 通过宏（地址），定义函数指针，并通过该指针在 boot_entry 函数中实现到 loader 程序的跳转
---

### 26 - 01 - 25

# :pensive: 我的爆爆 :confounded: My powder

---

### 26 - 01 - 26

#### 字符串内联方式显示

#### 内存容量检测
> - 犯了一个头文件编写错误，#ifndef写了#ifdef 
> - 在编译汇编文件 start.S 时，汇编器错误地尝试解析 C 语言头文件，导致编译失败，即在汇编文件中包含了 C 头文件
> - 进入保护模式期间，不要尝试使用show_msg函数去在qemu显示字符串，会导致进入不成功
