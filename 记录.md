# Linux 内核机制学习记录
## x86内核保护机制下的编程
### 26 - 01 - 04
&emsp; &emsp; 只是按照视频搭建加载过程

### 26 - 01 - 05
&emsp; &emsp; 理解了一点进入保护模式前的一些设置  

- 需要设置一个全局描述符（结构体数组）进行**属性配置**，根据内核数据段和代码段在全局描述符中对应的索引位置，对数据段和代码段的描述符进行属性配置（每个段对应一个64位值用于配置），具体代码如下:

<center> source/os.c : </center>

```c 
...
struct {uint16_t limit_l, base_l, basehl_attr, base_limit;}gdt_table[256] __attribute__((aligned(8))) = {
    [KERNEL_CODE_SEG / 8] = {0xFFFF, 0x0000, 0x9A00, 0x00CF},
    [KERNEL_DATA_SEG / 8] = {0xFFFF, 0x0000, 0x9200, 0x00CF},
};
...
```

<center> source/os.h : </center>

```c
...
#define KERNEL_CODE_SEG 0x08
#define KERNEL_DATA_SEG 0x10
...
```

- 涉及到的汇编代码主要是切换为**保护模式**——加载全局描述符->设置CR0寄存器PE位->远跳转->重新加载段寄存器，具体如下：
  
```asm
...
read_self_all:
	mov $start_32, %bx
	mov $0x02, %cx
	mov $0x240, %ax
	mov $0x80, %dx
	int $0x13 
	jc read_self_all
	// 下面的代码将处理器从实模式切换到保护模式
	cli                     // 关中断
	lgdt gdt_desc      // 加载全局描述符表
	mov $1, %eax          // 设置CR0寄存器的PE位
	lmsw %ax
	jmp $KERNEL_CODE_SEG, $start_32  // 跳转到32位代码段

	.org 0x1fe
	.byte 0x55, 0xaa  // 引导扇区的结束标志    

	// 32位保护模式, 位于512字节后
	.code32
	.text
    start_32:
	// 下面的代码将段寄存器重新加载为保护模式下的段选择子
	mov $KERNEL_DATA_SEG, %ax
	mov %ax, %ds
	mov %ax, %es
	mov %ax, %ss
	mov %ax, %gs
	mov %ax, %fs
	mov $_start, %esp
	jmp .

gdt_desc:
	.word (256 * 8) - 1	  // GDT表界限
	.long gdt_table                 // GDT表基地址
...
```


### 26 - 01 - 06
&emsp; &emsp; 学习分页机制——虚拟内存映射物理内存的一种机制

- 创建第一级页表——采用**PDE-4MB映射**
&emsp; &emsp; 这个页表元素采用**直接映射**——4MB以内的虚拟地址直接对应物理地址
```c
uint32_t pg_dir[1024] __attribute__((aligned(4096)))= {
    [0] = (0x00000000 | PDE_P | PDE_W | PDE_U | PDE_PS),          // 前4MB，4MB大页
};
```

- 创建第二级页表
```c
static uint32_t pg_table[1024] __attribute__((aligned(4096))) = {11};
```

- 创建实际物理地址buffer
```c
uint8_t map_phy_buffer[4096] __attribute__((aligned(4096))) = {123};
```

- 实现二级页表映射

&emsp; &emsp; 若map_phy_buffer实际地址位于4MB内，则其地址直接对应实际内存的物理地址
```c
void os_init(void){
    pg_dir[MAP_PHY_ADDR >> 22] = ((uint32_t)pg_table | PDE_P | PDE_W | PDE_U); 
    pg_table[MAP_PHY_ADDR >> 12 & 0x3FF] = (uint32_t)map_phy_buffer | PDE_P | PDE_W | PDE_U;
}
```

- 汇编代码的分页机制启动操作
```asm
	call os_init  // 调用os_init函数初始化操作系统
	
	// 下面的代码启用分页机制
	mov $pg_dir, %eax
	mov %eax, %cr3         // 加载页目录基地址到CR3寄存器

	mov %cr4, %eax
	orl $(1 << 4), %eax  // 设置CR4寄存器的PSE位
	mov %eax, %cr4        // 启用分页机制

	mov %cr0, %eax
	orl $(1 << 31), %eax  // 设置CR0寄存器的PG位
	mov %eax, %cr0        // 启用分页机制
```

### 26 - 01 - 07
&emsp; &emsp; 配置定时器

- 在C代码中使用汇编函数**outb**

&emsp; &emsp; 将数据val存入AL寄存器先，把port作为**立即数**存入Dx寄存器先，最后执行outb命令，将 AL 中的值输出到 port 指定的 I/O 端口
```c
void outb(uint8_t val, uint16_t port){
    __asm__ __volatile__ (
        "outb %0, %1"
        :
        : "a"(val), "d"(port)
    );
}
```

- 使用outb配置定时器

&emsp; &emsp; 这段代码通过向8259A中断控制器的特定端口写入配置值，配置了计算机的中断系统：首先向命令端口（0x20/0xA0）写入0x11告知开始初始化和初始化后使用数据端口（0x21/0xA1）会依次写入什么寄存器（可以看到后续使用同一个端口但是实际上写入了不同的寄存器），然后通过数据端口依次设置中断号重映射（0-15→32-47）、级联连接、操作模式和中断频率。
```c
void os_init(void){
	...
    outb(0x11, 0x20); // 主片
    outb(0x11, 0xA0); // 从片
    outb(0x20, 0x21); // 主片中断0-7映射到32-39
    outb(0x28, 0xA1); // 从片中断8-15映射到40-47
    outb(0x04, 0x21); // 主片IR2接从片
    outb(0x02, 0xA1); // 从片级联标志
    outb(0x01, 0x21); // 8086模式
    outb(0x01, 0xA1); // 8086模式
    outb(0xff, 0x21); // 屏蔽所有中断
    outb(0xff, 0xA1); // 屏蔽所有中断
	
	// 设置时钟中断频率为100ms
    int clock_100ms = 1193180 / 100; 
    outb((uint8_t)clock_100ms, 0x40);
    outb((clock_100ms >> 8) & 0xFF, 0x40);
}
```

- IDT表初始化

&emsp; &emsp; IDT（中断描述符表）是一张由操作系统维护的跳转表，用于告诉CPU当中断发生时应该跳转到哪个函数去处理。要使用它，需要：1）创建一个描述符数组；2）为每个中断号填充对应的描述符，包括处理函数的地址、代码段选择子和权限属性；3）用lidt指令将表的地址和大小加载到CPU。这样当中断发生时，CPU就能自动查找并跳转到你指定的处理函数。
```c
struct{uint16_t offset_l, selector, attr, offset_h;}idt_table[256] __attribute__((aligned(8))) = {1};

void os_init(void){
	...

	idt_table[0x20].offset_l = irq0_handler & 0xFFFF;
    idt_table[0x20].selector = KERNEL_CODE_SEG;
    idt_table[0x20].attr = 0x8E00; 
    idt_table[0x20].offset_h = irq0_handler >> 16;
	...

	outb(0xFE, 0x21); // 取消中断屏蔽，打开时钟中断IRQ0
}
```

- 汇编需要的操作
  
 &emsp; &emsp; 1.描述并加载IDT表<br>
 &emsp; &emsp; 2.开中断<br>
 &emsp; &emsp; 3.描述中断处理内容，并且声明C代码里的中断函数
```c
	#include "os.h"
	// 声明本地以下符号是全局的，在其它源文件中可以访问
	.global _start, irq0_handler
	// 指定以下的代码生成16位的机器指令，这样才能在启动时的实模式下运行
  	.code16
	// 以下是代码区
 	.text
_start: 
    ...
	

read_self_all:
	...

	// 下面的代码将处理器从实模式切换到保护模式
	cli                     // 关中断
	lgdt gdt_desc      // 加载全局描述符表
	lidt idt_desc      // 加载中断描述符表
	...

	// 32位保护模式, 位于512字节后
	.code32
	.text
start_32:
	...

	sti					 // 开中断


irq0_handler:
	push %ds
	pusha
	mov $0x20, %al
	outb %al, $0x20       // 通知PIC芯片IRQ0中断处理完毕
	popa
	pop %ds
	iret

idt_desc:
	.word (256 * 8) - 1	  // IDT表界限
	.long idt_table                 // IDT表基地址
```

### 26 - 01 - 08
    
&emsp; &emsp; Github上传配置

### 26 - 01 - 09
    
&emsp; &emsp; 切换至低特权级 + 任务切换
- 切换低特权级

&emsp; &emsp; 1. 选用用户空间选择子 并设置其GDT描述符
   
```c
os.h:

#define APP_CODE_SEG    (0x18 | 3)
#define APP_DATA_SEG    (0x20 | 3)


os.c:

struct {uint16_t limit_l, base_l, basehl_attr, base_limit;}gdt_table[256] __attribute__((aligned(8))) = {
    ...

    [APP_CODE_SEG / 8]    = {0xFFFF, 0x0000, 0xFA00, 0x00CF},
    [APP_DATA_SEG / 8]    = {0xFFFF, 0x0000, 0xF300, 0x00CF},
};
```
&emsp; &emsp; 2. 刻意构造一次“中断-返回”机制，跳转低特权级任务   

```asm
start_32:
	...

	push $APP_DATA_SEG
	push $task_0_stack + 1024 * 4 // 任务0的栈顶地址
	// 以下代码模拟中断返回，跳转到任务0入口点运行
	push $0x202 	 // EFLAGS寄存器的IF位设置为1，启用中断
	push $APP_CODE_SEG
	push $task_0_entry
	iret              // 通过iret指令跳转到任务0入口点
	...

task_0_entry:
	mov %ss, %ax
	mov %ax, %ds
	mov %ax, %es
	mov %ax, %gs
	mov %ax, %fs
	jmp .

```
<br>

- 任务切换

&emsp; &emsp; 1. 在.h头文件添加TSS选择子
```c
os.h:

#define TASK0_TSS_SEL   0x28
#define TASK1_TSS_SEL   0x30
```

&emsp; &emsp; 2. 在C源文件补充必要数据结构

&emsp; &emsp; &emsp; 2.1 任务栈<br>
&emsp; &emsp; &emsp; 2.2 任务工作函数<br>
&emsp; &emsp; &emsp; 2.3 TSS详细定义(?)<br>
&emsp; &emsp; &emsp; 2.4 修改GDT表-添加TSS描述符(?)<br>
&emsp; &emsp; &emsp; 2.5 增加任务调度函数(?)<br>

```c
...

// 2.1 任务栈定义（每个任务需要两个栈：DPL0和DPL3）
uint32_t task0_dpl0_stack[1024], task0_dpl3_stack[1024];
uint32_t task1_dpl0_stack[1024], task1_dpl3_stack[1024];
...

// 2.2 任务工作函数
void task_0 (void) {
    for (;;) {
    }
}

void task_1(void) {
    for (;;) {
    }
}
...

// 2.3 TSS 详细定义
// 任务0的TSS定义
uint32_t task0_tss[] = {
    // prelink, esp0, ss0, esp1, ss1, esp2, ss2
    0,  (uint32_t)task0_dpl0_stack + 4*1024, KERNEL_DATA_SEG, 
    0x0, 0x0, 0x0, 0x0,  // esp1-ss2不用
    
    // cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi
    (uint32_t)pg_dir,  (uint32_t)task_0, 0x202,  // 页目录、入口点、标志
    0xa, 0xc, 0xd, 0xb,                         // eax, ecx, edx, ebx
    (uint32_t)task0_dpl3_stack + 4*1024,        // 用户栈（esp）
    0x1, 0x2, 0x3,                              // ebp, esi, edi
    
    // es, cs, ss, ds, fs, gs, ldt, iomap
    APP_DATA_SEG, APP_CODE_SEG, APP_DATA_SEG, 
    APP_DATA_SEG, APP_DATA_SEG, APP_DATA_SEG, 
    0x0, 0x0,                                   // ldt, iomap
};

// 任务1的TSS定义
uint32_t task1_tss[] = {
    // prelink, esp0, ss0, esp1, ss1, esp2, ss2
    0,  (uint32_t)task1_dpl0_stack + 4*1024, KERNEL_DATA_SEG,
    0x0, 0x0, 0x0, 0x0,
    
    // cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi
    (uint32_t)pg_dir,  (uint32_t)task_1, 0x202,
    0xa, 0xc, 0xd, 0xb,
    (uint32_t)task1_dpl3_stack + 4*1024,        // 用户栈
    0x1, 0x2, 0x3,
    
    // es, cs, ss, ds, fs, gs, ldt, iomap
    APP_DATA_SEG, APP_CODE_SEG, APP_DATA_SEG,
    APP_DATA_SEG, APP_DATA_SEG, APP_DATA_SEG,
    0x0, 0x0,
};
...

// 2.4 GDT表新增TSS项
struct {uint16_t limit_l, base_l, basehl_attr, base_limit;}gdt_table[256] __attribute__((aligned(8))) = {
    ...

    [TASK0_TSS_SEL / 8]   = {0x0068, 0, 0xE900, 0x0},  
    [TASK1_TSS_SEL / 8]   = {0x0068, 0, 0xE900, 0x0},
};
...

// 2.5 任务调度函数
void task_sched(void) {
    static int current_task = TASK0_TSS_SEL;
    
    // 切换任务
    if (current_task == TASK0_TSS_SEL) {
        current_task = TASK1_TSS_SEL;
    } else {
        current_task = TASK0_TSS_SEL;
    }
    
    // 使用远跳转切换到新任务
    // 这个数组[0, 选择子]构成一个48位远指针
    uint32_t jump_addr[] = {0, current_task};
    
    // ljmpl指令：跳转到TSS选择子，触发任务切换
    __asm__ __volatile__("ljmpl *(%0)" : : "r"(jump_addr));
}


// 2.6 os_init末尾添加TSS初始化
void os_init(void){
	...

    gdt_table[TASK0_TSS_SEL / 8].base_l = (uint16_t)((uint32_t)task0_tss & 0xFFFF);
    gdt_table[TASK0_TSS_SEL / 8].basehl_attr |= ((uint32_t)os_init >> 16) & 0xFF;
    gdt_table[TASK0_TSS_SEL / 8].base_limit |= ((uint32_t)task0_tss >> 24) << 24;
    
    gdt_table[TASK1_TSS_SEL / 8].base_l = (uint16_t)((uint32_t)task1_tss & 0xFFFF);
    gdt_table[TASK1_TSS_SEL / 8].basehl_attr |= ((uint32_t)task1_tss >> 16) & 0xFF;
    gdt_table[TASK1_TSS_SEL / 8].base_limit |= ((uint32_t)task1_tss >> 24) << 24;
}
```

&emsp; &emsp; 3. 汇编文件修改

&emsp; &emsp; &emsp; 3.1 修改start.S中的irq0_handler：<br>
&emsp; &emsp; &emsp; 3.2 修改start.S的start_32部分<br>
&emsp; &emsp; &emsp; 3.3 修改task0_entry<br>
```asm
...

// 3.1 修改irq0_handler
irq0_handler:
	...

    mov $KERNEL_DATA_SEG, %ax
    mov %ax, %ds
    mov %ax, %es
    
    call task_sched
	...

// 3.2 修改start_32
start_32:
    ...

    mov $TASK0_TSS_SEL, %ax
    ltr %ax

	push $APP_DATA_SEG
	push $task0_dpl0_stack + 1024 * 4 // 任务0的栈顶地址
    ...

// 3.3 修改task0_entry
task_0_entry:
    ...

	jmp task_0


```

### 26 - 01 - 10
&emsp; &emsp; 1. 对 26 - 01 - 09 的工作进行收尾<br>
&emsp; &emsp; 2. 增加系统调用 并在os_init中补充其起始地址的设置<br>
&emsp; &emsp; &emsp; 2.1 limit_l 指定系统调用处理函数syscall_handler 在C文件和汇编文件提前声明<br>
&emsp; &emsp; 3. 在汇编函数增加 syscall_handler标签<br>
&emsp; &emsp; 4. 增加一个通用的函数 do_syscall, 这个函数是在syscall_handler函数里面使用的<br>
&emsp; &emsp; 5. 增加一个函数 sys_show, 这个函数主要功能就是显示字符串 涉及到一些在C语言内调用汇编的操作

1. 头文件增加相应系统调用选择子，并在gdt表中初始化选择符
2. 

- 字符串显示使用系统调用函数

